"""Base strategy framework components.

Provides abstract base class and context for strategy development.
This is the NEW strategy framework that runs strategies in individual threads
with selective subscriptions.

Note: This is separate from the legacy BaseStrategy in analysis_engine.py
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Tuple, Dict, Any, Optional
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class SignalAction(Enum):
    """Trading signal actions."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE = "CLOSE"


@dataclass
class Signal:
    """Trading signal generated by strategy.
    
    Attributes:
        symbol: Symbol to trade
        action: Buy/sell/hold/close
        quantity: Number of shares (optional)
        price: Target price (optional)
        reason: Explanation for signal
        metadata: Additional signal data
    """
    symbol: str
    action: SignalAction
    quantity: Optional[int] = None
    price: Optional[float] = None
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyContext:
    """Context provided to strategies.
    
    Provides access to:
    - SessionData (zero-copy bar access)
    - TimeManager (current time)
    - Performance metrics
    - System configuration
    
    Attributes:
        session_data: Zero-copy access to all market data
        time_manager: Access to time operations
        system_manager: Access to system services
        mode: Execution mode (live, backtest)
    """
    session_data: Any  # SessionData
    time_manager: Any  # TimeManager
    system_manager: Any  # SystemManager
    mode: str  # "live", "backtest"
    
    def get_current_time(self):
        """Get current time (live or backtest).
        
        Returns:
            Current datetime
        """
        return self.time_manager.get_current_time()
    
    def get_bars(self, symbol: str, interval: str):
        """Get bars reference (zero-copy).
        
        Args:
            symbol: Symbol to get bars for
            interval: Interval (e.g., "5m")
            
        Returns:
            Reference to deque of bars
        """
        return self.session_data.get_bars_ref(symbol, interval)
    
    def get_bar_quality(self, symbol: str, interval: str) -> float:
        """Get bar quality percentage.
        
        Args:
            symbol: Symbol to check
            interval: Interval (e.g., "5m")
            
        Returns:
            Quality percentage (0-100)
        """
        quality = self.session_data.get_quality_metric(symbol, interval)
        return quality if quality is not None else 0.0


class BaseStrategy(ABC):
    """Abstract base class for all strategies.
    
    This is the NEW strategy framework that supports:
    - Individual thread per strategy
    - Selective subscriptions
    - Mode-aware synchronization
    - Performance monitoring
    
    Lifecycle:
        1. __init__(name, config) - Create instance
        2. setup(context) - Initialize (return True/False)
        3. on_bars(symbol, interval) - Process data (return signals)
        4. teardown(context) - Cleanup
    
    Subclasses must implement:
        - get_subscriptions() - Which (symbol, interval) pairs to subscribe to
        - on_bars(symbol, interval) - Generate signals from new data
    
    Optional hooks:
        - setup(context) - Initialize strategy state
        - teardown(context) - Cleanup resources
        - on_symbol_added(symbol) - React to mid-session symbol addition
        - on_quality_update(symbol, interval, quality) - React to quality changes
    """
    
    def __init__(self, name: str, config: Dict[str, Any]):
        """Initialize strategy.
        
        Args:
            name: Unique strategy name
            config: Strategy configuration from session_config
        """
        self.name = name
        self.config = config
        self.context: Optional[StrategyContext] = None
        self._logger = logging.getLogger(f"strategy.{name}")
    
    # =========================================================================
    # Required Methods (Must Override)
    # =========================================================================
    
    @abstractmethod
    def get_subscriptions(self) -> List[Tuple[str, str]]:
        """Get list of (symbol, interval) subscriptions.
        
        Called during initialization to determine which data to route to
        this strategy.
        
        Returns:
            List of (symbol, interval) tuples
            Example: [("AAPL", "5m"), ("GOOGL", "5m")]
        """
        pass
    
    @abstractmethod
    def on_bars(self, symbol: str, interval: str) -> List[Signal]:
        """Process new bar data and generate signals.
        
        Called when subscribed data arrives. Strategy should:
        1. Access bars via self.context.get_bars(symbol, interval)
        2. Calculate indicators
        3. Generate signals
        
        Args:
            symbol: Symbol with new data
            interval: Interval with new data
            
        Returns:
            List of trading signals (can be empty)
        """
        pass
    
    # =========================================================================
    # Optional Hooks (Can Override)
    # =========================================================================
    
    def setup(self, context: StrategyContext) -> bool:
        """Initialize strategy.
        
        Called once during strategy loading. Use this to:
        - Store context
        - Validate config parameters
        - Initialize state
        - Load external data
        
        Args:
            context: Strategy context with system access
            
        Returns:
            True if setup successful, False to abort strategy loading
        """
        self.context = context
        self._logger.info(f"Strategy '{self.name}' setup complete")
        return True
    
    def teardown(self, context: StrategyContext):
        """Cleanup strategy resources.
        
        Called during shutdown. Use this to:
        - Close files
        - Flush logs
        - Save state
        
        Args:
            context: Strategy context
        """
        self._logger.info(f"Strategy '{self.name}' teardown complete")
    
    def on_symbol_added(self, symbol: str):
        """React to mid-session symbol addition.
        
        Called when scanner adds new symbol. Strategy can:
        - Update subscriptions (handled automatically)
        - Initialize state for new symbol
        - Log the event
        
        Args:
            symbol: Symbol that was added
        """
        self._logger.info(f"New symbol added: {symbol}")
    
    def on_quality_update(self, symbol: str, interval: str, quality: float):
        """React to data quality changes.
        
        Called when data quality drops below threshold. Strategy can:
        - Log warning
        - Adjust parameters
        - Stop trading this symbol
        
        Args:
            symbol: Symbol with quality issue
            interval: Interval with quality issue
            quality: Current quality percentage (0-100)
        """
        if quality < 95.0:
            self._logger.warning(
                f"Low quality: {symbol} {interval} = {quality:.1f}%"
            )
    
    # =========================================================================
    # Helper Methods
    # =========================================================================
    
    def log_signal(self, signal: Signal):
        """Log trading signal.
        
        Args:
            signal: Signal to log
        """
        self._logger.info(
            f"SIGNAL: {signal.action.value} {signal.symbol} "
            f"qty={signal.quantity} reason={signal.reason}"
        )


# Export public API
__all__ = [
    'BaseStrategy',
    'StrategyContext',
    'Signal',
    'SignalAction',
]
