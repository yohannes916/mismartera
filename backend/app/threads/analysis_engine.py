"""
Analysis Engine - Event-Driven Strategy Execution & Signal Generation

This is a NEW COMPONENT for the session architecture (Phase 7).

Key Responsibilities:
1. Consume processed data from SessionData (ONLY source of data)
2. Execute trading strategies
3. Generate trading signals
4. Make trading decisions with risk management
5. Quality-aware decision making

Architecture Reference: SESSION_ARCHITECTURE.md - Section 4 (Analysis Engine Thread)

Thread Launch Sequence:
  SystemManager → SessionCoordinator → DataProcessor → AnalysisEngine

Dependencies (Phase 1-6):
- SessionData (Phase 1.1) - ONLY data source (zero-copy access)
- StreamSubscription (Phase 1.2) - Thread synchronization with DataProcessor
- PerformanceMetrics (Phase 1.3) - Monitoring
- SessionConfig (Phase 2.1) - Configuration
- TimeManager (Phase 2.2) - Time operations
- SessionCoordinator (Phase 3) - Historical data provider
- DataProcessor (Phase 4) - Notification source
- DataQualityManager (Phase 5) - Quality scores

Key Design:
- Event-driven: Wait on notification queue from DataProcessor
- Zero-copy: Read from SessionData by reference, never copy
- Bidirectional sync: Receive notifications + signal ready to processor
- Mode-aware: Data-driven (blocking) vs clock-driven (OverrunError)
- Quality-aware: Factor quality into trading decisions
- Strategy-based: Pluggable strategy framework
"""

import threading
import queue
import time
from datetime import datetime
from typing import Optional, Dict, List, Any, Tuple
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
from enum import Enum

# Logging
from app.logger import logger

# Phase 1-6 components
from app.managers.data_manager.session_data import SessionData, get_session_data
from app.threads.sync.stream_subscription import StreamSubscription
from app.monitoring.performance_metrics import PerformanceMetrics
from app.models.session_config import SessionConfig


# =========================================================================
# Signal & Decision Data Structures
# =========================================================================

class SignalAction(Enum):
    """Trading signal actions."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


@dataclass
class Signal:
    """Trading signal generated by strategy.
    
    Represents a trading opportunity identified by a strategy.
    """
    symbol: str
    action: SignalAction
    quantity: int
    price: float
    timestamp: datetime
    strategy_name: str
    confidence: float  # 0.0 to 1.0
    interval: str  # Data interval used (e.g., "5m")
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __str__(self) -> str:
        return (
            f"Signal({self.action.value} {self.quantity} {self.symbol} @ ${self.price:.2f}, "
            f"confidence={self.confidence:.2f}, strategy={self.strategy_name})"
        )


@dataclass
class Decision:
    """Trading decision with approval status.
    
    Represents whether a signal was approved for execution after
    risk management and quality checks.
    """
    signal: Signal
    approved: bool
    reason: str
    timestamp: datetime
    quality_score: float = 100.0
    
    def __str__(self) -> str:
        status = "APPROVED" if self.approved else "REJECTED"
        return f"Decision({status}: {self.signal}, reason={self.reason})"


# =========================================================================
# Strategy Framework
# =========================================================================

class BaseStrategy(ABC):
    """Base class for all trading strategies.
    
    All strategies must inherit from this class and implement
    the required methods.
    """
    
    def __init__(self, name: str, session_data: SessionData, config: Dict[str, Any]):
        """Initialize strategy.
        
        Args:
            name: Strategy name
            session_data: Reference to SessionData for zero-copy access
            config: Strategy configuration dictionary
        """
        self.name = name
        self.session_data = session_data
        self.config = config
        self.enabled = config.get('enabled', True)
        
        logger.info(f"Strategy '{name}' initialized")
    
    @abstractmethod
    def on_bar(self, symbol: str, interval: str, bar: Any) -> List[Signal]:
        """Called when new bar arrives.
        
        Args:
            symbol: Symbol with new bar
            interval: Bar interval
            bar: Bar data
        
        Returns:
            List of generated signals (empty if none)
        """
        pass
    
    @abstractmethod
    def on_bars(self, symbol: str, interval: str) -> List[Signal]:
        """Called with notification about new bars.
        
        Can read all bars from SessionData.
        
        Args:
            symbol: Symbol with new bars
            interval: Bar interval
        
        Returns:
            List of generated signals (empty if none)
        """
        pass
    
    def on_quality_update(self, symbol: str, interval: str, quality: float):
        """Called when quality score changes.
        
        Optional callback for quality-aware strategies.
        
        Args:
            symbol: Symbol with quality update
            interval: Interval
            quality: New quality score (0-100)
        """
        pass


# =========================================================================
# Analysis Engine Thread
# =========================================================================

class AnalysisEngine(threading.Thread):
    """Event-driven analysis engine for strategy execution and signal generation.
    
    This engine runs in its own thread and:
    1. Waits for notifications from DataProcessor
    2. Reads data from SessionData (zero-copy)
    3. Executes loaded strategies
    4. Generates trading signals
    5. Makes trading decisions with risk management
    6. Signals ready to DataProcessor
    
    Thread Safety:
    - Runs in own thread (managed by SystemManager)
    - Uses StreamSubscription for sync with DataProcessor
    - Thread-safe reads from SessionData
    
    Data Access:
    - ALL data read from SessionData (single interface)
    - Historical bars, current session bars, indicators, quality
    - Zero-copy access (reference-based)
    """
    
    def __init__(
        self,
        session_data: SessionData,
        system_manager,
        session_config: SessionConfig,
        metrics: PerformanceMetrics
    ):
        """Initialize Analysis Engine.
        
        Args:
            session_data: Reference to SessionData (ONLY data source)
            system_manager: Reference to SystemManager
            session_config: Session configuration
            metrics: Performance metrics tracker
        """
        super().__init__(name="AnalysisEngine", daemon=True)
        
        # Core dependencies
        self.session_data = session_data
        self._system_manager = system_manager
        self._time_manager = system_manager.get_time_manager()
        self.session_config = session_config
        self.metrics = metrics
        
        # Thread control
        self._stop_event = threading.Event()
        self._running = False
        
        # Notification queue (from DataProcessor)
        self._notification_queue: queue.Queue[Tuple[str, str, str]] = queue.Queue()
        
        # StreamSubscription for signaling ready to processor
        self._processor_subscription: Optional[StreamSubscription] = None
        
        # Mode detection
        self.mode = "backtest" if session_config.backtest_config else "live"
        self.speed = 0  # Will be set from config
        if self.mode == "backtest" and session_config.backtest_config:
            self.speed = session_config.backtest_config.speed_multiplier
        
        # Loaded strategies
        self._strategies: List[BaseStrategy] = []
        
        # Risk management configuration
        self._min_quality_threshold = 95.0  # Minimum quality to trade
        self._max_position_size = 100  # Maximum shares per position
        self._max_positions_per_symbol = 1  # Maximum positions per symbol
        
        # Statistics
        self._signals_generated = 0
        self._decisions_made = 0
        self._decisions_approved = 0
        self._decisions_rejected = 0
        self._processing_times: List[float] = []
        
        logger.info(
            f"AnalysisEngine initialized: mode={self.mode}, "
            f"speed={self.speed}, quality_threshold={self._min_quality_threshold}"
        )
    
    # =========================================================================
    # Configuration & Setup
    # =========================================================================
    
    def set_notification_queue(self, queue_ref: queue.Queue):
        """Set notification queue (called by SystemManager).
        
        Args:
            queue_ref: Queue receiving notifications from DataProcessor
        """
        self._notification_queue = queue_ref
        logger.info("Notification queue wired to analysis engine")
    
    def set_processor_subscription(self, subscription: StreamSubscription):
        """Set processor subscription (called by SystemManager).
        
        Args:
            subscription: StreamSubscription for signaling ready to processor
        """
        self._processor_subscription = subscription
        logger.info("Processor subscription wired to analysis engine")
    
    def register_strategy(self, strategy: BaseStrategy):
        """Register a strategy for execution.
        
        Args:
            strategy: Strategy instance to register
        """
        self._strategies.append(strategy)
        logger.info(f"Strategy registered: {strategy.name}")
    
    # =========================================================================
    # Thread Lifecycle
    # =========================================================================
    
    def run(self):
        """Main thread entry point - starts event-driven processing loop."""
        self._running = True
        logger.info("AnalysisEngine thread started")
        
        try:
            self._processing_loop()
        except Exception as e:
            logger.error(f"AnalysisEngine thread crashed: {e}", exc_info=True)
        finally:
            self._running = False
            logger.info("AnalysisEngine thread stopped")
    
    def stop(self):
        """Signal thread to stop."""
        logger.info("Stopping AnalysisEngine...")
        self._stop_event.set()
        
        # Unblock queue if waiting
        try:
            self._notification_queue.put(None, block=False)
        except:
            pass
    
    def join(self, timeout=None):
        """Wait for thread to stop.
        
        Args:
            timeout: Maximum time to wait (seconds)
        """
        if self.is_alive():
            super().join(timeout)
            if self.is_alive():
                logger.warning("AnalysisEngine did not stop gracefully")
            else:
                logger.info("AnalysisEngine stopped gracefully")
    
    # =========================================================================
    # Main Processing Loop (Event-Driven)
    # =========================================================================
    
    def _processing_loop(self):
        """Main event-driven processing loop.
        
        Waits for notifications from DataProcessor, executes strategies,
        generates signals, makes decisions, and signals ready.
        
        Flow:
        1. Wait on notification queue (blocking with timeout)
        2. Read data from SessionData (zero-copy)
        3. Execute strategies
        4. Generate signals
        5. Make trading decisions
        6. Signal ready to processor
        7. Record metrics
        """
        logger.info("Starting event-driven analysis loop")
        
        while not self._stop_event.is_set():
            try:
                # 1. Wait for notification (blocking with timeout for graceful shutdown)
                try:
                    notification = self._notification_queue.get(timeout=1.0)
                except queue.Empty:
                    continue
                
                # Check for stop signal
                if notification is None or self._stop_event.is_set():
                    break
                
                # Parse notification: (symbol, interval, data_type)
                symbol, interval, data_type = notification
                
                logger.debug(
                    f"Processing notification: {symbol} {interval} {data_type}"
                )
                
                # Start timing
                start_time = self.metrics.start_timer()
                
                # 2. Read data from SessionData (ZERO-COPY: direct reference)
                bars_ref = self.session_data.get_bars_ref(symbol, interval)
                quality = self.session_data.get_quality_metric(symbol, interval)
                
                if not bars_ref:
                    logger.debug(f"No bars for {symbol} {interval}, skipping")
                    continue
                
                logger.debug(
                    f"Processing {symbol} {interval}: {len(bars_ref)} bars, "
                    f"quality={quality:.1f}%"
                )
                
                # 3. Execute strategies and generate signals (pass zero-copy reference)
                signals = self._execute_strategies(symbol, interval, bars_ref)
                
                # 4. Make trading decisions
                if signals:
                    decisions = self._make_decisions(signals, quality)
                    
                    # Log approved decisions
                    for decision in decisions:
                        if decision.approved:
                            logger.info(f"APPROVED: {decision}")
                        else:
                            logger.debug(f"REJECTED: {decision}")
                
                # 5. Signal ready to processor
                self._signal_ready_to_processor()
                
                # 6. Record metrics
                elapsed = self.metrics.elapsed_time(start_time)
                self._processing_times.append(elapsed)
                self.metrics.record_analysis_engine(start_time)
                
                logger.debug(f"Processed {symbol} {interval} in {elapsed:.3f}s")
                
            except Exception as e:
                logger.error(
                    f"Error processing notification: {e}",
                    exc_info=True
                )
        
        logger.info("Analysis loop exited")
    
    # =========================================================================
    # Strategy Execution
    # =========================================================================
    
    def _execute_strategies(
        self,
        symbol: str,
        interval: str,
        bars: List[Any]
    ) -> List[Signal]:
        """Execute all registered strategies.
        
        Args:
            symbol: Symbol to analyze
            interval: Bar interval
            bars: Bar data
        
        Returns:
            List of generated signals (empty if none)
        """
        all_signals = []
        
        for strategy in self._strategies:
            if not strategy.enabled:
                continue
            
            try:
                # Execute strategy
                signals = strategy.on_bars(symbol, interval)
                
                if signals:
                    logger.debug(
                        f"Strategy '{strategy.name}' generated {len(signals)} signal(s) "
                        f"for {symbol} {interval}"
                    )
                    all_signals.extend(signals)
                    self._signals_generated += len(signals)
            
            except Exception as e:
                logger.error(
                    f"Error executing strategy '{strategy.name}': {e}",
                    exc_info=True
                )
        
        return all_signals
    
    # =========================================================================
    # Decision Making & Risk Management
    # =========================================================================
    
    def _make_decisions(
        self,
        signals: List[Signal],
        quality: float
    ) -> List[Decision]:
        """Make trading decisions with risk management.
        
        Applies quality filtering and risk checks to signals.
        
        Args:
            signals: Signals to evaluate
            quality: Data quality score
        
        Returns:
            List of decisions (approved or rejected)
        """
        decisions = []
        current_time = self._time_manager.get_current_time()
        
        for signal in signals:
            self._decisions_made += 1
            
            # 1. Check quality threshold
            if quality < self._min_quality_threshold:
                decision = Decision(
                    signal=signal,
                    approved=False,
                    reason=f"Low quality ({quality:.1f}% < {self._min_quality_threshold}%)",
                    timestamp=current_time,
                    quality_score=quality
                )
                self._decisions_rejected += 1
                decisions.append(decision)
                continue
            
            # 2. Check position size
            if signal.quantity > self._max_position_size:
                decision = Decision(
                    signal=signal,
                    approved=False,
                    reason=f"Position size too large ({signal.quantity} > {self._max_position_size})",
                    timestamp=current_time,
                    quality_score=quality
                )
                self._decisions_rejected += 1
                decisions.append(decision)
                continue
            
            # 3. Check confidence threshold
            min_confidence = 0.5
            if signal.confidence < min_confidence:
                decision = Decision(
                    signal=signal,
                    approved=False,
                    reason=f"Low confidence ({signal.confidence:.2f} < {min_confidence})",
                    timestamp=current_time,
                    quality_score=quality
                )
                self._decisions_rejected += 1
                decisions.append(decision)
                continue
            
            # All checks passed - approve
            decision = Decision(
                signal=signal,
                approved=True,
                reason="All checks passed",
                timestamp=current_time,
                quality_score=quality
            )
            self._decisions_approved += 1
            decisions.append(decision)
        
        return decisions
    
    # =========================================================================
    # Processor Synchronization
    # =========================================================================
    
    def _signal_ready_to_processor(self):
        """Signal ready to data processor.
        
        Mode-aware signaling:
        - Data-driven: Always signal (blocks processor until ready)
        - Clock-driven: Check if ready, raise OverrunError if not
        """
        if not self._processor_subscription:
            return
        
        try:
            self._processor_subscription.signal_ready()
            logger.debug("Signaled ready to data processor")
        except Exception as e:
            logger.error(f"Error signaling ready to processor: {e}", exc_info=True)
    
    # =========================================================================
    # Statistics & Metrics
    # =========================================================================
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get analysis engine statistics.
        
        Returns:
            Dictionary with statistics
        """
        avg_processing_time = (
            sum(self._processing_times) / len(self._processing_times)
            if self._processing_times else 0.0
        )
        
        return {
            "running": self._running,
            "mode": self.mode,
            "speed": self.speed,
            "strategies_loaded": len(self._strategies),
            "signals_generated": self._signals_generated,
            "decisions_made": self._decisions_made,
            "decisions_approved": self._decisions_approved,
            "decisions_rejected": self._decisions_rejected,
            "approval_rate": (
                (self._decisions_approved / self._decisions_made * 100.0)
                if self._decisions_made > 0 else 0.0
            ),
            "avg_processing_time": avg_processing_time,
            "min_quality_threshold": self._min_quality_threshold
        }
