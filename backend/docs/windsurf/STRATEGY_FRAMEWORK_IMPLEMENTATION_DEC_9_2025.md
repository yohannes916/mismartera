# Strategy Framework Implementation Plan - December 9, 2025

## Overview

Detailed implementation plan for the new strategy framework, following the proven scanner framework pattern with extensive testing.

---

## Implementation Phases

### Phase 1: Foundation (Days 1-2)
**Goal**: Create base classes and directory structure

### Phase 2: Threading Infrastructure (Days 3-4)
**Goal**: Implement StrategyThread and queue management

### Phase 3: Manager Layer (Days 5-6)
**Goal**: Implement StrategyManager and lifecycle

### Phase 4: Integration (Days 7-8)
**Goal**: Wire into SystemManager and DataProcessor

### Phase 5: Testing (Days 9-12)
**Goal**: Comprehensive unit, integration, and E2E tests

---

## Phase 1: Foundation (Days 1-2)

### 1.1 Directory Structure

```
backend/
├── app/
│   └── strategies/
│       ├── __init__.py
│       ├── base.py              # BaseStrategy, StrategyContext
│       ├── manager.py           # StrategyManager
│       ├── thread.py            # StrategyThread
│       └── examples/
│           ├── __init__.py
│           └── simple_ma_cross.py
└── strategies/                  # User strategies (empty initially)
    ├── __init__.py
    ├── examples/
    │   ├── __init__.py
    │   ├── simple_ma_cross.py
    │   ├── rsi_strategy.py
    │   └── vwap_strategy.py
    └── production/
        └── __init__.py
```

### 1.2 Create app/strategies/base.py

```python
"""Base strategy framework components.

Provides abstract base class and context for strategy development.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Tuple, Dict, Any, Optional
from enum import Enum
import logging

logger = logging.getLogger(__name__)


class SignalAction(Enum):
    """Trading signal actions."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE = "CLOSE"


@dataclass
class Signal:
    """Trading signal generated by strategy.
    
    Attributes:
        symbol: Symbol to trade
        action: Buy/sell/hold/close
        quantity: Number of shares (optional)
        price: Target price (optional)
        reason: Explanation for signal
        metadata: Additional signal data
    """
    symbol: str
    action: SignalAction
    quantity: Optional[int] = None
    price: Optional[float] = None
    reason: str = ""
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class StrategyContext:
    """Context provided to strategies.
    
    Provides access to:
    - SessionData (zero-copy bar access)
    - TimeManager (current time)
    - Performance metrics
    - System configuration
    
    Attributes:
        session_data: Zero-copy access to all market data
        time_manager: Time operations (current_time, etc.)
        system_manager: Access to system services
        mode: Execution mode (live, backtest)
    """
    session_data: Any  # SessionData
    time_manager: Any  # TimeManager
    system_manager: Any  # SystemManager
    mode: str  # "live", "backtest"
    
    def get_current_time(self):
        """Get current time (live or backtest)."""
        return self.time_manager.get_current_time()
    
    def get_bars(self, symbol: str, interval: str):
        """Get bars reference (zero-copy).
        
        Args:
            symbol: Symbol to get bars for
            interval: Interval (e.g., "5m")
            
        Returns:
            Reference to deque of bars
        """
        return self.session_data.get_bars_ref(symbol, interval)
    
    def get_bar_quality(self, symbol: str, interval: str) -> float:
        """Get bar quality percentage.
        
        Args:
            symbol: Symbol to check
            interval: Interval (e.g., "5m")
            
        Returns:
            Quality percentage (0-100)
        """
        return self.session_data.get_bar_quality(symbol, interval)


class BaseStrategy(ABC):
    """Abstract base class for all strategies.
    
    Lifecycle:
        1. __init__(name, config) - Create instance
        2. setup(context) - Initialize (return True/False)
        3. on_bars(symbol, interval) - Process data (return signals)
        4. teardown(context) - Cleanup
    
    Subclasses must implement:
        - get_subscriptions() - Which (symbol, interval) pairs to subscribe to
        - on_bars(symbol, interval) - Generate signals from new data
    
    Optional hooks:
        - setup(context) - Initialize strategy state
        - teardown(context) - Cleanup resources
        - on_symbol_added(symbol) - React to mid-session symbol addition
        - on_quality_update(symbol, interval, quality) - React to quality changes
    """
    
    def __init__(self, name: str, config: Dict[str, Any]):
        """Initialize strategy.
        
        Args:
            name: Unique strategy name
            config: Strategy configuration from session_config
        """
        self.name = name
        self.config = config
        self.context: Optional[StrategyContext] = None
        self._logger = logging.getLogger(f"strategy.{name}")
    
    # =========================================================================
    # Required Methods (Must Override)
    # =========================================================================
    
    @abstractmethod
    def get_subscriptions(self) -> List[Tuple[str, str]]:
        """Get list of (symbol, interval) subscriptions.
        
        Called during initialization to determine which data to route to
        this strategy.
        
        Returns:
            List of (symbol, interval) tuples
            Example: [("AAPL", "5m"), ("GOOGL", "5m")]
        """
        pass
    
    @abstractmethod
    def on_bars(self, symbol: str, interval: str) -> List[Signal]:
        """Process new bar data and generate signals.
        
        Called when subscribed data arrives. Strategy should:
        1. Access bars via self.context.get_bars(symbol, interval)
        2. Calculate indicators
        3. Generate signals
        
        Args:
            symbol: Symbol with new data
            interval: Interval with new data
            
        Returns:
            List of trading signals (can be empty)
        """
        pass
    
    # =========================================================================
    # Optional Hooks (Can Override)
    # =========================================================================
    
    def setup(self, context: StrategyContext) -> bool:
        """Initialize strategy.
        
        Called once during strategy loading. Use this to:
        - Store context
        - Validate config parameters
        - Initialize state
        - Load external data
        
        Args:
            context: Strategy context with system access
            
        Returns:
            True if setup successful, False to abort strategy loading
        """
        self.context = context
        self._logger.info(f"Strategy '{self.name}' setup complete")
        return True
    
    def teardown(self, context: StrategyContext):
        """Cleanup strategy resources.
        
        Called during shutdown. Use this to:
        - Close files
        - Flush logs
        - Save state
        
        Args:
            context: Strategy context
        """
        self._logger.info(f"Strategy '{self.name}' teardown complete")
    
    def on_symbol_added(self, symbol: str):
        """React to mid-session symbol addition.
        
        Called when scanner adds new symbol. Strategy can:
        - Update subscriptions (handled automatically)
        - Initialize state for new symbol
        - Log the event
        
        Args:
            symbol: Symbol that was added
        """
        self._logger.info(f"New symbol added: {symbol}")
    
    def on_quality_update(self, symbol: str, interval: str, quality: float):
        """React to data quality changes.
        
        Called when data quality drops below threshold. Strategy can:
        - Log warning
        - Adjust parameters
        - Stop trading this symbol
        
        Args:
            symbol: Symbol with quality issue
            interval: Interval with quality issue
            quality: Current quality percentage (0-100)
        """
        if quality < 95.0:
            self._logger.warning(
                f"Low quality: {symbol} {interval} = {quality:.1f}%"
            )
    
    # =========================================================================
    # Helper Methods
    # =========================================================================
    
    def log_signal(self, signal: Signal):
        """Log trading signal.
        
        Args:
            signal: Signal to log
        """
        self._logger.info(
            f"SIGNAL: {signal.action.value} {signal.symbol} "
            f"qty={signal.quantity} reason={signal.reason}"
        )


# Export public API
__all__ = [
    'BaseStrategy',
    'StrategyContext',
    'Signal',
    'SignalAction',
]
```

### 1.3 Create app/models/strategy_config.py

```python
"""Strategy configuration models."""
from dataclasses import dataclass, field
from typing import Dict, Any


@dataclass
class StrategyConfig:
    """Strategy configuration from session_config.
    
    Attributes:
        module: Python module path (e.g., "strategies.examples.simple_ma_cross")
        enabled: Whether strategy is enabled
        config: Strategy-specific configuration
    """
    module: str
    enabled: bool = True
    config: Dict[str, Any] = field(default_factory=dict)
    
    def validate(self) -> None:
        """Validate strategy configuration."""
        if not self.module:
            raise ValueError("Strategy module path is required")
        
        # Module path validation (basic check)
        if not all(part.isidentifier() for part in self.module.split('.')):
            raise ValueError(f"Invalid module path: {self.module}")
```

### 1.4 Update app/models/session_config.py

Add strategies field to SessionDataConfig:

```python
from app.models.strategy_config import StrategyConfig

@dataclass
class SessionDataConfig:
    symbols: List[str]
    streams: List[str]
    streaming: StreamingConfig = field(default_factory=StreamingConfig)
    historical: HistoricalConfig = field(default_factory=HistoricalConfig)
    gap_filler: GapFillerConfig = field(default_factory=GapFillerConfig)
    indicators: IndicatorsConfig = field(default_factory=IndicatorsConfig)
    scanners: List[ScannerConfig] = field(default_factory=list)
    strategies: List[StrategyConfig] = field(default_factory=list)  # NEW
```

### 1.5 Create Example Strategy

```python
# strategies/examples/simple_ma_cross.py
"""Simple moving average crossover strategy."""
from typing import List, Tuple
from collections import deque

from app.strategies.base import BaseStrategy, StrategyContext, Signal, SignalAction


class SimpleMaCrossStrategy(BaseStrategy):
    """Moving average crossover strategy.
    
    Generates BUY signal when fast MA crosses above slow MA.
    Generates SELL signal when fast MA crosses below slow MA.
    
    Config Parameters:
        symbols (List[str]): Symbols to trade
        interval (str): Bar interval (e.g., "5m")
        fast_period (int): Fast MA period (default: 10)
        slow_period (int): Slow MA period (default: 20)
        min_quality (float): Minimum data quality % (default: 95.0)
    """
    
    def setup(self, context: StrategyContext) -> bool:
        """Initialize strategy parameters."""
        # Call parent setup
        if not super().setup(context):
            return False
        
        # Extract config parameters
        self.symbols = self.config.get('symbols', [])
        self.interval = self.config.get('interval', '5m')
        self.fast_period = self.config.get('fast_period', 10)
        self.slow_period = self.config.get('slow_period', 20)
        self.min_quality = self.config.get('min_quality', 95.0)
        
        # Validate parameters
        if not self.symbols:
            self._logger.error("No symbols configured")
            return False
        
        if self.fast_period >= self.slow_period:
            self._logger.error("fast_period must be < slow_period")
            return False
        
        if self.fast_period <= 0 or self.slow_period <= 0:
            self._logger.error("Periods must be positive")
            return False
        
        self._logger.info(
            f"Initialized with {len(self.symbols)} symbols, "
            f"interval={self.interval}, fast={self.fast_period}, slow={self.slow_period}"
        )
        
        # Initialize state tracking
        self._last_signal = {}  # Track last signal per symbol
        
        return True
    
    def get_subscriptions(self) -> List[Tuple[str, str]]:
        """Subscribe to configured symbols and interval."""
        return [(symbol, self.interval) for symbol in self.symbols]
    
    def on_bars(self, symbol: str, interval: str) -> List[Signal]:
        """Generate signals based on MA crossover."""
        # Only process subscribed data
        if symbol not in self.symbols or interval != self.interval:
            return []
        
        # Check data quality
        quality = self.context.get_bar_quality(symbol, interval)
        if quality < self.min_quality:
            self._logger.warning(
                f"Skipping {symbol} - quality {quality:.1f}% < {self.min_quality}%"
            )
            return []
        
        # Get bars (zero-copy reference)
        bars = self.context.get_bars(symbol, interval)
        
        # Need enough bars for slow MA
        if len(bars) < self.slow_period:
            return []
        
        # Calculate MAs
        fast_ma = self._calculate_ma(bars, self.fast_period)
        slow_ma = self._calculate_ma(bars, self.slow_period)
        
        if fast_ma is None or slow_ma is None:
            return []
        
        # Get previous MAs (for crossover detection)
        prev_fast_ma = self._calculate_ma(bars, self.fast_period, offset=1)
        prev_slow_ma = self._calculate_ma(bars, self.slow_period, offset=1)
        
        if prev_fast_ma is None or prev_slow_ma is None:
            return []
        
        # Detect crossover
        signals = []
        
        # Bullish crossover (fast crosses above slow)
        if prev_fast_ma <= prev_slow_ma and fast_ma > slow_ma:
            if self._last_signal.get(symbol) != 'BUY':
                signal = Signal(
                    symbol=symbol,
                    action=SignalAction.BUY,
                    reason=f"Fast MA ({fast_ma:.2f}) crossed above slow MA ({slow_ma:.2f})",
                    metadata={
                        'fast_ma': fast_ma,
                        'slow_ma': slow_ma,
                        'interval': interval
                    }
                )
                signals.append(signal)
                self.log_signal(signal)
                self._last_signal[symbol] = 'BUY'
        
        # Bearish crossover (fast crosses below slow)
        elif prev_fast_ma >= prev_slow_ma and fast_ma < slow_ma:
            if self._last_signal.get(symbol) != 'SELL':
                signal = Signal(
                    symbol=symbol,
                    action=SignalAction.SELL,
                    reason=f"Fast MA ({fast_ma:.2f}) crossed below slow MA ({slow_ma:.2f})",
                    metadata={
                        'fast_ma': fast_ma,
                        'slow_ma': slow_ma,
                        'interval': interval
                    }
                )
                signals.append(signal)
                self.log_signal(signal)
                self._last_signal[symbol] = 'SELL'
        
        return signals
    
    def _calculate_ma(self, bars: deque, period: int, offset: int = 0) -> float:
        """Calculate simple moving average.
        
        Args:
            bars: Bar data
            period: MA period
            offset: Offset from end (0=latest, 1=previous, etc.)
            
        Returns:
            MA value or None if insufficient data
        """
        if len(bars) < period + offset:
            return None
        
        # Get slice of bars
        end_idx = len(bars) - offset
        start_idx = end_idx - period
        
        if start_idx < 0:
            return None
        
        # Calculate average of close prices
        bars_list = list(bars)
        total = sum(bar.close for bar in bars_list[start_idx:end_idx])
        return total / period


# Required: Export strategy class
__all__ = ['SimpleMaCrossStrategy']
```

### 1.6 Files to Create

- [x] `app/strategies/__init__.py`
- [x] `app/strategies/base.py`
- [x] `app/models/strategy_config.py`
- [x] `strategies/__init__.py`
- [x] `strategies/examples/__init__.py`
- [x] `strategies/examples/simple_ma_cross.py`
- [x] `strategies/production/__init__.py`

---

## Phase 2: Threading Infrastructure (Days 3-4)

### 2.1 Create app/strategies/thread.py

```python
"""Strategy thread implementation."""
import threading
import queue
import time
from typing import Optional, Tuple
import logging

from app.strategies.base import BaseStrategy, StrategyContext
from app.threads.sync.stream_subscription import StreamSubscription

logger = logging.getLogger(__name__)


class StrategyThread(threading.Thread):
    """Thread for running a single strategy.
    
    Each strategy runs in its own thread with:
    - Dedicated notification queue
    - StreamSubscription for sync with DataProcessor
    - Performance metrics tracking
    - Pause/resume support
    
    Attributes:
        strategy: Strategy instance
        mode: Execution mode ("data-driven", "clock-driven", "live")
        context: Strategy context
    """
    
    def __init__(
        self,
        strategy: BaseStrategy,
        context: StrategyContext,
        mode: str
    ):
        """Initialize strategy thread.
        
        Args:
            strategy: Strategy instance to run
            context: Strategy context
            mode: Execution mode
        """
        super().__init__(name=f"Strategy-{strategy.name}", daemon=True)
        
        self.strategy = strategy
        self.context = context
        self.mode = mode
        
        # Thread control
        self._stop_event = threading.Event()
        self._queue = queue.Queue()
        
        # Synchronization with DataProcessor
        self._subscription = StreamSubscription(
            mode=mode,
            stream_id=f"processor->strategy:{strategy.name}"
        )
        
        # Performance metrics
        self._notifications_processed = 0
        self._signals_generated = 0
        self._errors = 0
        self._total_processing_time = 0.0
        self._max_processing_time = 0.0
        
        logger.info(f"Created strategy thread: {strategy.name} (mode={mode})")
    
    # =========================================================================
    # Thread Lifecycle
    # =========================================================================
    
    def run(self):
        """Main thread loop."""
        logger.info(f"[{self.strategy.name}] Starting strategy thread")
        
        try:
            self._processing_loop()
        except Exception as e:
            logger.error(f"[{self.strategy.name}] Fatal error: {e}", exc_info=True)
        finally:
            logger.info(f"[{self.strategy.name}] Strategy thread exiting")
    
    def stop(self):
        """Signal thread to stop."""
        logger.info(f"[{self.strategy.name}] Stop requested")
        self._stop_event.set()
        # Put sentinel to unblock queue.get()
        try:
            self._queue.put(None, block=False)
        except queue.Full:
            pass
    
    def join(self, timeout=None):
        """Wait for thread to finish."""
        super().join(timeout=timeout)
        if self.is_alive():
            logger.warning(f"[{self.strategy.name}] Thread did not exit in time")
    
    # =========================================================================
    # Notification Queue
    # =========================================================================
    
    def notify(self, symbol: str, interval: str, data_type: str = "bars"):
        """Add notification to queue.
        
        Called by DataProcessor when subscribed data arrives.
        
        Args:
            symbol: Symbol with new data
            interval: Interval with new data
            data_type: Type of data ("bars", "quotes", etc.)
        """
        try:
            self._queue.put((symbol, interval, data_type), block=False)
        except queue.Full:
            logger.warning(f"[{self.strategy.name}] Queue full - dropping notification")
            self._errors += 1
    
    def get_queue_size(self) -> int:
        """Get current queue size."""
        return self._queue.qsize()
    
    # =========================================================================
    # Main Processing Loop
    # =========================================================================
    
    def _processing_loop(self):
        """Main processing loop."""
        while not self._stop_event.is_set():
            try:
                # Wait for notification (with timeout for stop check)
                notification = self._queue.get(timeout=1.0)
                
                if notification is None:
                    # Sentinel value - exit
                    break
                
                # Process notification
                self._process_notification(notification)
                
            except queue.Empty:
                # Timeout - check stop event
                continue
            except Exception as e:
                logger.error(
                    f"[{self.strategy.name}] Error in processing loop: {e}",
                    exc_info=True
                )
                self._errors += 1
    
    def _process_notification(self, notification: Tuple[str, str, str]):
        """Process a single notification.
        
        Args:
            notification: (symbol, interval, data_type) tuple
        """
        symbol, interval, data_type = notification
        
        start_time = time.time()
        
        try:
            # Call strategy's on_bars method
            signals = self.strategy.on_bars(symbol, interval)
            
            # Track signals
            if signals:
                self._signals_generated += len(signals)
                logger.debug(
                    f"[{self.strategy.name}] Generated {len(signals)} signals "
                    f"for {symbol} {interval}"
                )
            
            # Update metrics
            self._notifications_processed += 1
            processing_time = time.time() - start_time
            self._total_processing_time += processing_time
            self._max_processing_time = max(self._max_processing_time, processing_time)
            
            # Signal ready to DataProcessor
            self._subscription.signal_ready()
            
        except Exception as e:
            logger.error(
                f"[{self.strategy.name}] Error processing {symbol} {interval}: {e}",
                exc_info=True
            )
            self._errors += 1
            
            # Still signal ready (don't block DataProcessor)
            self._subscription.signal_ready()
    
    # =========================================================================
    # Subscription Management
    # =========================================================================
    
    def get_subscription(self) -> StreamSubscription:
        """Get StreamSubscription for DataProcessor sync.
        
        Returns:
            StreamSubscription instance
        """
        return self._subscription
    
    # =========================================================================
    # Performance Metrics
    # =========================================================================
    
    def get_metrics(self) -> dict:
        """Get performance metrics.
        
        Returns:
            Dictionary of metrics
        """
        avg_time = (
            self._total_processing_time / self._notifications_processed
            if self._notifications_processed > 0
            else 0.0
        )
        
        return {
            'strategy_name': self.strategy.name,
            'running': self.is_alive(),
            'mode': self.mode,
            'notifications_processed': self._notifications_processed,
            'signals_generated': self._signals_generated,
            'errors': self._errors,
            'queue_size': self.get_queue_size(),
            'avg_processing_time_ms': avg_time * 1000,
            'max_processing_time_ms': self._max_processing_time * 1000,
            'overruns': self._subscription._overrun_count if hasattr(self._subscription, '_overrun_count') else 0,
        }
```

### 2.2 Files to Create

- [x] `app/strategies/thread.py`

---

## Phase 3: Manager Layer (Days 5-6)

### 3.1 Create app/strategies/manager.py

```python
"""Strategy manager - orchestrates all strategies."""
import importlib
import logging
from typing import List, Dict, Set, Tuple
from pathlib import Path

from app.strategies.base import BaseStrategy, StrategyContext
from app.strategies.thread import StrategyThread
from app.models.strategy_config import StrategyConfig

logger = logging.getLogger(__name__)


class StrategyManager:
    """Manages all strategy threads.
    
    Responsibilities:
    - Load strategies from config
    - Create strategy threads
    - Manage subscriptions
    - Track performance
    - Coordinate lifecycle
    
    Similar to ScannerManager but for continuous event-driven strategies.
    """
    
    def __init__(self, system_manager):
        """Initialize strategy manager.
        
        Args:
            system_manager: SystemManager instance
        """
        self._system_manager = system_manager
        
        # Strategy threads
        self._strategy_threads: List[StrategyThread] = []
        
        # Subscription tracking: (symbol, interval) -> [StrategyThread, ...]
        self._subscriptions: Dict[Tuple[str, str], List[StrategyThread]] = {}
        
        # State
        self._initialized = False
        self._running = False
        
        logger.info("StrategyManager created")
    
    # =========================================================================
    # Lifecycle
    # =========================================================================
    
    def initialize(self) -> bool:
        """Initialize strategy manager.
        
        Loads strategies from session_config and creates threads.
        
        Returns:
            True if initialization successful
        """
        if self._initialized:
            logger.warning("StrategyManager already initialized")
            return True
        
        logger.info("Initializing StrategyManager...")
        
        try:
            # Get strategies from config
            session_config = self._system_manager.session_config
            strategies_config = session_config.session_data_config.strategies
            
            if not strategies_config:
                logger.info("No strategies configured")
                self._initialized = True
                return True
            
            # Load each strategy
            for strategy_config in strategies_config:
                if not strategy_config.enabled:
                    logger.info(f"Strategy '{strategy_config.module}' disabled - skipping")
                    continue
                
                # Load strategy
                success = self._load_strategy(strategy_config)
                if not success:
                    logger.error(f"Failed to load strategy: {strategy_config.module}")
                    return False
            
            # Build subscription map
            self._build_subscription_map()
            
            logger.info(
                f"StrategyManager initialized with {len(self._strategy_threads)} strategies"
            )
            self._initialized = True
            return True
            
        except Exception as e:
            logger.error(f"Failed to initialize StrategyManager: {e}", exc_info=True)
            return False
    
    def start_strategies(self) -> bool:
        """Start all strategy threads.
        
        Returns:
            True if all strategies started successfully
        """
        if not self._initialized:
            logger.error("Cannot start - not initialized")
            return False
        
        if self._running:
            logger.warning("Strategies already running")
            return True
        
        logger.info("Starting all strategies...")
        
        try:
            for thread in self._strategy_threads:
                # Call strategy setup
                success = thread.strategy.setup(thread.context)
                if not success:
                    logger.error(f"Strategy {thread.strategy.name} setup failed")
                    return False
                
                # Start thread
                thread.start()
                logger.info(f"Started strategy: {thread.strategy.name}")
            
            self._running = True
            logger.info(f"All {len(self._strategy_threads)} strategies running")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start strategies: {e}", exc_info=True)
            return False
    
    def stop_strategies(self):
        """Stop all strategy threads."""
        if not self._running:
            logger.info("Strategies not running")
            return
        
        logger.info("Stopping all strategies...")
        
        # Signal all threads to stop
        for thread in self._strategy_threads:
            thread.stop()
        
        # Wait for all to finish
        for thread in self._strategy_threads:
            thread.join(timeout=5.0)
            if thread.is_alive():
                logger.warning(f"Strategy {thread.strategy.name} did not stop cleanly")
        
        # Call teardown
        for thread in self._strategy_threads:
            try:
                thread.strategy.teardown(thread.context)
            except Exception as e:
                logger.error(
                    f"Error in {thread.strategy.name} teardown: {e}",
                    exc_info=True
                )
        
        self._running = False
        logger.info("All strategies stopped")
    
    def shutdown(self):
        """Shutdown strategy manager."""
        logger.info("Shutting down StrategyManager...")
        
        if self._running:
            self.stop_strategies()
        
        # Clear data structures
        self._strategy_threads.clear()
        self._subscriptions.clear()
        self._initialized = False
        
        logger.info("StrategyManager shutdown complete")
    
    # =========================================================================
    # Strategy Loading
    # =========================================================================
    
    def _load_strategy(self, config: StrategyConfig) -> bool:
        """Load a single strategy.
        
        Args:
            config: Strategy configuration
            
        Returns:
            True if loaded successfully
        """
        try:
            # Import module
            module = importlib.import_module(config.module)
            
            # Find strategy class
            strategy_class = self._find_strategy_class(module, config.module)
            if not strategy_class:
                logger.error(f"No strategy class found in {config.module}")
                return False
            
            # Extract name from module
            name = config.module.split('.')[-1]
            
            # Create strategy instance
            strategy = strategy_class(name=name, config=config.config)
            
            # Create context
            context = self._create_context()
            
            # Determine mode
            mode = self._determine_mode()
            
            # Create thread
            thread = StrategyThread(
                strategy=strategy,
                context=context,
                mode=mode
            )
            
            self._strategy_threads.append(thread)
            logger.info(f"Loaded strategy: {name} ({strategy_class.__name__})")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to load strategy {config.module}: {e}", exc_info=True)
            return False
    
    def _find_strategy_class(self, module, module_path: str):
        """Find strategy class in module.
        
        Looks for class that:
        1. Inherits from BaseStrategy
        2. Name matches module name (e.g., simple_ma_cross -> SimpleMaCrossStrategy)
        
        Args:
            module: Python module
            module_path: Module path string
            
        Returns:
            Strategy class or None
        """
        # Convert module name to class name
        # simple_ma_cross -> SimpleMaCrossStrategy
        module_name = module_path.split('.')[-1]
        expected_class_name = ''.join(word.capitalize() for word in module_name.split('_')) + 'Strategy'
        
        # Look for class
        for attr_name in dir(module):
            attr = getattr(module, attr_name)
            if (
                isinstance(attr, type) and
                issubclass(attr, BaseStrategy) and
                attr is not BaseStrategy
            ):
                # Check if name matches
                if attr.__name__ == expected_class_name:
                    return attr
                
                # Fallback: any BaseStrategy subclass
                logger.warning(
                    f"Found {attr.__name__} but expected {expected_class_name}"
                )
                return attr
        
        return None
    
    def _create_context(self) -> StrategyContext:
        """Create strategy context.
        
        Returns:
            StrategyContext instance
        """
        return StrategyContext(
            session_data=self._system_manager.get_session_data(),
            time_manager=self._system_manager.get_time_manager(),
            system_manager=self._system_manager,
            mode=self._system_manager.mode.value
        )
    
    def _determine_mode(self) -> str:
        """Determine execution mode for StreamSubscription.
        
        Returns:
            "data-driven", "clock-driven", or "live"
        """
        if self._system_manager.mode.value == "live":
            return "live"
        
        # Backtest mode
        speed = self._system_manager.session_config.backtest_config.speed_multiplier
        return "data-driven" if speed == 0 else "clock-driven"
    
    # =========================================================================
    # Subscription Management
    # =========================================================================
    
    def _build_subscription_map(self):
        """Build map of subscriptions.
        
        Creates mapping: (symbol, interval) -> [StrategyThread, ...]
        """
        self._subscriptions.clear()
        
        for thread in self._strategy_threads:
            subscriptions = thread.strategy.get_subscriptions()
            
            for symbol, interval in subscriptions:
                key = (symbol, interval)
                if key not in self._subscriptions:
                    self._subscriptions[key] = []
                self._subscriptions[key].append(thread)
        
        logger.info(
            f"Built subscription map: {len(self._subscriptions)} unique subscriptions"
        )
    
    def get_subscribed_threads(
        self,
        symbol: str,
        interval: str
    ) -> List[StrategyThread]:
        """Get threads subscribed to (symbol, interval).
        
        Args:
            symbol: Symbol
            interval: Interval
            
        Returns:
            List of subscribed StrategyThread instances
        """
        return self._subscriptions.get((symbol, interval), [])
    
    def get_all_subscriptions(self) -> Set[Tuple[str, str]]:
        """Get all (symbol, interval) subscriptions.
        
        Returns:
            Set of (symbol, interval) tuples
        """
        return set(self._subscriptions.keys())
    
    # =========================================================================
    # Notification Routing
    # =========================================================================
    
    def notify_strategies(self, symbol: str, interval: str, data_type: str = "bars"):
        """Notify subscribed strategies of new data.
        
        Called by DataProcessor when new data arrives.
        Routes notification only to subscribed strategies.
        
        Args:
            symbol: Symbol with new data
            interval: Interval with new data
            data_type: Type of data
        """
        threads = self.get_subscribed_threads(symbol, interval)
        
        for thread in threads:
            thread.notify(symbol, interval, data_type)
    
    def wait_for_strategies(self, timeout: float = None) -> bool:
        """Wait for all strategies to signal ready.
        
        Called by DataProcessor after notifying strategies.
        Blocks in data-driven mode, times out in clock-driven/live.
        
        Args:
            timeout: Timeout in seconds (None = infinite for data-driven)
            
        Returns:
            True if all ready, False if timeout
        """
        mode = self._determine_mode()
        
        # Determine timeout
        if mode == "data-driven":
            actual_timeout = None  # Block indefinitely
        else:
            actual_timeout = timeout if timeout is not None else 0.1
        
        all_ready = True
        
        for thread in self._strategy_threads:
            subscription = thread.get_subscription()
            ready = subscription.wait_until_ready(timeout=actual_timeout)
            
            if not ready:
                all_ready = False
                logger.warning(
                    f"Strategy {thread.strategy.name} timeout "
                    f"(overruns={subscription._overrun_count})"
                )
            
            subscription.reset()
        
        return all_ready
    
    # =========================================================================
    # Performance Metrics
    # =========================================================================
    
    def get_metrics(self) -> dict:
        """Get aggregate metrics.
        
        Returns:
            Dictionary of system-wide metrics
        """
        strategy_metrics = [thread.get_metrics() for thread in self._strategy_threads]
        
        total_notifications = sum(m['notifications_processed'] for m in strategy_metrics)
        total_signals = sum(m['signals_generated'] for m in strategy_metrics)
        total_errors = sum(m['errors'] for m in strategy_metrics)
        
        # Find bottleneck
        slowest = max(
            strategy_metrics,
            key=lambda m: m['avg_processing_time_ms']
        ) if strategy_metrics else None
        
        return {
            'total_strategies': len(self._strategy_threads),
            'active_strategies': sum(1 for m in strategy_metrics if m['running']),
            'total_subscriptions': len(self._subscriptions),
            'total_notifications_processed': total_notifications,
            'total_signals_generated': total_signals,
            'total_errors': total_errors,
            'slowest_strategy': slowest['strategy_name'] if slowest else None,
            'slowest_avg_time_ms': slowest['avg_processing_time_ms'] if slowest else 0,
            'strategies': strategy_metrics,
        }
    
    # =========================================================================
    # Mid-Session Symbol Addition
    # =========================================================================
    
    def notify_symbol_added(self, symbol: str):
        """Notify strategies of new symbol.
        
        Called when scanner adds symbol mid-session.
        
        Args:
            symbol: Symbol that was added
        """
        logger.info(f"Notifying strategies of new symbol: {symbol}")
        
        for thread in self._strategy_threads:
            try:
                thread.strategy.on_symbol_added(symbol)
            except Exception as e:
                logger.error(
                    f"Error notifying {thread.strategy.name}: {e}",
                    exc_info=True
                )
        
        # Rebuild subscription map (strategies may have updated subscriptions)
        self._build_subscription_map()
```

### 3.2 Files to Create

- [x] `app/strategies/manager.py`

---

## Phase 4: Integration (Days 7-8)

### 4.1 Update SystemManager

```python
# In app/managers/system_manager/api.py

# Add to imports
from app.strategies.manager import StrategyManager

# Add to __init__
self._strategy_manager: Optional[StrategyManager] = None

# Add getter
def get_strategy_manager(self) -> StrategyManager:
    """Get strategy manager."""
    if self._strategy_manager is None:
        raise RuntimeError("StrategyManager not initialized")
    return self._strategy_manager

# Update start_session
def start_session(self, session_config: SessionConfig):
    # ... existing code ...
    
    # Create strategy manager
    self._strategy_manager = StrategyManager(self)
    
    # Initialize strategies
    if not self._strategy_manager.initialize():
        raise RuntimeError("Failed to initialize strategies")
    
    # ... existing code ...
    
    # Start strategies
    if not self._strategy_manager.start_strategies():
        raise RuntimeError("Failed to start strategies")

# Update stop_session
def stop_session(self):
    # Stop strategies first
    if self._strategy_manager:
        self._strategy_manager.stop_strategies()
    
    # ... existing code ...

# Update shutdown
def shutdown(self):
    # Shutdown strategy manager
    if self._strategy_manager:
        self._strategy_manager.shutdown()
        self._strategy_manager = None
    
    # ... existing code ...
```

### 4.2 Update DataProcessor

```python
# In app/threads/data_processor.py

# Add to _process_bars method (after processing bars)
def _process_bars(self, symbol: str, interval: str):
    # ... existing bar processing code ...
    
    # Notify strategies (if strategy manager exists)
    strategy_manager = self._system_manager.get_strategy_manager()
    if strategy_manager:
        strategy_manager.notify_strategies(symbol, interval, "bars")
        
        # Wait for strategies (mode-aware blocking)
        strategy_manager.wait_for_strategies()
    
    # ... existing analysis engine notification ...
```

### 4.3 Update SessionCoordinator

```python
# In app/threads/session_coordinator.py

# Add to mid-session symbol insertion
def _insert_symbols_mid_session(self, symbols: List[str]):
    # ... existing symbol registration code ...
    
    # Notify strategy manager
    strategy_manager = self._system_manager.get_strategy_manager()
    if strategy_manager:
        for symbol in symbols:
            strategy_manager.notify_symbol_added(symbol)
```

---

## Phase 5: Testing (Days 9-12)

### Test Structure

```
tests/
├── unit/
│   ├── strategies/
│   │   ├── test_base_strategy.py
│   │   ├── test_strategy_thread.py
│   │   ├── test_strategy_manager.py
│   │   └── test_strategy_config.py
│   └── examples/
│       └── test_simple_ma_cross.py
├── integration/
│   ├── test_strategy_lifecycle.py
│   ├── test_strategy_subscriptions.py
│   ├── test_strategy_notifications.py
│   └── test_strategy_synchronization.py
└── e2e/
    ├── test_strategy_data_driven.py
    ├── test_strategy_clock_driven.py
    ├── test_strategy_with_scanners.py
    └── test_multiple_strategies.py
```

### 5.1 Unit Tests

#### test_base_strategy.py
```python
"""Unit tests for BaseStrategy."""
import pytest
from app.strategies.base import BaseStrategy, StrategyContext, Signal, SignalAction


class MockStrategy(BaseStrategy):
    """Mock strategy for testing."""
    
    def get_subscriptions(self):
        return [("AAPL", "5m")]
    
    def on_bars(self, symbol, interval):
        return []


def test_strategy_initialization():
    """Test strategy initialization."""
    config = {"test_param": 123}
    strategy = MockStrategy("test_strategy", config)
    
    assert strategy.name == "test_strategy"
    assert strategy.config == config
    assert strategy.context is None


def test_strategy_setup():
    """Test strategy setup."""
    strategy = MockStrategy("test", {})
    context = MockStrategy  # Mock context
    
    result = strategy.setup(context)
    
    assert result is True
    assert strategy.context is context


def test_strategy_subscriptions():
    """Test subscription retrieval."""
    strategy = MockStrategy("test", {})
    
    subs = strategy.get_subscriptions()
    
    assert len(subs) == 1
    assert subs[0] == ("AAPL", "5m")


def test_signal_creation():
    """Test signal creation."""
    signal = Signal(
        symbol="AAPL",
        action=SignalAction.BUY,
        quantity=100,
        reason="Test signal"
    )
    
    assert signal.symbol == "AAPL"
    assert signal.action == SignalAction.BUY
    assert signal.quantity == 100
    assert signal.metadata == {}
```

#### test_strategy_thread.py
```python
"""Unit tests for StrategyThread."""
import pytest
import time
from app.strategies.thread import StrategyThread
from app.strategies.base import BaseStrategy, StrategyContext


class TestStrategy(BaseStrategy):
    def __init__(self, name, config):
        super().__init__(name, config)
        self.calls = []
    
    def get_subscriptions(self):
        return [("AAPL", "5m")]
    
    def on_bars(self, symbol, interval):
        self.calls.append((symbol, interval))
        return []


@pytest.fixture
def mock_context():
    """Create mock context."""
    # Create mock objects
    return StrategyContext(
        session_data=None,
        time_manager=None,
        system_manager=None,
        mode="backtest"
    )


def test_thread_creation(mock_context):
    """Test thread creation."""
    strategy = TestStrategy("test", {})
    thread = StrategyThread(strategy, mock_context, "data-driven")
    
    assert thread.strategy is strategy
    assert thread.mode == "data-driven"
    assert not thread.is_alive()


def test_thread_lifecycle(mock_context):
    """Test thread start and stop."""
    strategy = TestStrategy("test", {})
    thread = StrategyThread(strategy, mock_context, "data-driven")
    
    # Start thread
    thread.start()
    time.sleep(0.1)
    assert thread.is_alive()
    
    # Stop thread
    thread.stop()
    thread.join(timeout=1.0)
    assert not thread.is_alive()


def test_notification_routing(mock_context):
    """Test notification routing to strategy."""
    strategy = TestStrategy("test", {})
    thread = StrategyThread(strategy, mock_context, "data-driven")
    
    # Setup strategy
    strategy.setup(mock_context)
    
    # Start thread
    thread.start()
    time.sleep(0.1)
    
    # Send notification
    thread.notify("AAPL", "5m")
    time.sleep(0.2)
    
    # Check strategy received it
    assert len(strategy.calls) == 1
    assert strategy.calls[0] == ("AAPL", "5m")
    
    # Cleanup
    thread.stop()
    thread.join(timeout=1.0)


def test_metrics_tracking(mock_context):
    """Test performance metrics."""
    strategy = TestStrategy("test", {})
    thread = StrategyThread(strategy, mock_context, "data-driven")
    
    # Setup and start
    strategy.setup(mock_context)
    thread.start()
    time.sleep(0.1)
    
    # Send notifications
    thread.notify("AAPL", "5m")
    thread.notify("AAPL", "5m")
    time.sleep(0.2)
    
    # Check metrics
    metrics = thread.get_metrics()
    assert metrics['notifications_processed'] == 2
    assert metrics['strategy_name'] == 'test'
    
    # Cleanup
    thread.stop()
    thread.join(timeout=1.0)
```

#### test_strategy_manager.py
```python
"""Unit tests for StrategyManager."""
import pytest
from unittest.mock import Mock, MagicMock
from app.strategies.manager import StrategyManager


@pytest.fixture
def mock_system_manager():
    """Create mock SystemManager."""
    mgr = Mock()
    
    # Mock session config
    config = Mock()
    config.session_data_config.strategies = []
    config.mode.value = "backtest"
    config.backtest_config.speed_multiplier = 0
    mgr.session_config = config
    
    # Mock managers
    mgr.get_session_data.return_value = Mock()
    mgr.get_time_manager.return_value = Mock()
    mgr.mode.value = "backtest"
    
    return mgr


def test_manager_creation(mock_system_manager):
    """Test manager creation."""
    manager = StrategyManager(mock_system_manager)
    
    assert manager._system_manager is mock_system_manager
    assert not manager._initialized
    assert not manager._running


def test_initialize_no_strategies(mock_system_manager):
    """Test initialization with no strategies."""
    manager = StrategyManager(mock_system_manager)
    
    result = manager.initialize()
    
    assert result is True
    assert manager._initialized
    assert len(manager._strategy_threads) == 0


def test_subscription_map():
    """Test subscription map building."""
    # This would require mocking strategy loading
    # Implement after strategy loading is complete
    pass
```

### 5.2 Integration Tests

#### test_strategy_lifecycle.py
```python
"""Integration tests for strategy lifecycle."""
import pytest
from app.strategies.manager import StrategyManager
from app.models.session_config import SessionConfig


@pytest.fixture
def session_config_with_strategy():
    """Create session config with strategy."""
    # Load from test config file
    pass


def test_full_lifecycle(session_config_with_strategy):
    """Test full strategy lifecycle."""
    # 1. Initialize manager
    # 2. Load strategies
    # 3. Start strategies
    # 4. Send notifications
    # 5. Verify signals
    # 6. Stop strategies
    # 7. Verify cleanup
    pass
```

#### test_strategy_subscriptions.py
```python
"""Integration tests for strategy subscriptions."""


def test_selective_subscriptions():
    """Test that strategies only receive subscribed data."""
    pass


def test_multiple_strategies_same_subscription():
    """Test multiple strategies subscribing to same data."""
    pass


def test_subscription_map_updates():
    """Test subscription map updates when symbols added."""
    pass
```

#### test_strategy_synchronization.py
```python
"""Integration tests for synchronization."""


def test_data_driven_blocking():
    """Test data-driven mode blocks DataProcessor."""
    pass


def test_clock_driven_timeout():
    """Test clock-driven mode times out if strategy slow."""
    pass


def test_backpressure_detection():
    """Test backpressure metrics when strategy can't keep up."""
    pass
```

### 5.3 E2E Tests

#### test_strategy_data_driven.py
```python
"""E2E test for data-driven backtest with strategies."""
import pytest
from datetime import datetime


@pytest.mark.e2e
def test_data_driven_with_single_strategy():
    """Test data-driven backtest with single strategy.
    
    Verifies:
    - Strategy receives all bars
    - Signals generated correctly
    - No data loss
    - Deterministic results
    """
    pass


@pytest.mark.e2e
def test_data_driven_with_slow_strategy():
    """Test that slow strategy controls pace in data-driven mode."""
    pass


@pytest.mark.e2e
def test_data_driven_signal_generation():
    """Test complete signal generation flow."""
    pass
```

#### test_strategy_clock_driven.py
```python
"""E2E test for clock-driven backtest with strategies."""


@pytest.mark.e2e
def test_clock_driven_with_fast_strategy():
    """Test clock-driven backtest with fast strategy."""
    pass


@pytest.mark.e2e
def test_clock_driven_with_slow_strategy():
    """Test that slow strategy gets overruns in clock-driven mode."""
    pass


@pytest.mark.e2e
def test_clock_driven_backpressure_metrics():
    """Test backpressure metrics collection."""
    pass
```

#### test_strategy_with_scanners.py
```python
"""E2E test for strategies with scanners."""


@pytest.mark.e2e
def test_scanner_and_strategy_integration():
    """Test scanner adds symbols that strategies trade.
    
    Flow:
    1. Start session with scanner
    2. Scanner runs and finds symbols
    3. Symbols added mid-session
    4. Strategies notified
    5. Strategies trade new symbols
    """
    pass


@pytest.mark.e2e
def test_pause_for_scanner():
    """Test pause/resume during scanner execution."""
    pass
```

#### test_multiple_strategies.py
```python
"""E2E test with multiple concurrent strategies."""


@pytest.mark.e2e
def test_two_strategies_different_symbols():
    """Test two strategies trading different symbols."""
    pass


@pytest.mark.e2e
def test_two_strategies_same_symbol():
    """Test two strategies trading same symbol."""
    pass


@pytest.mark.e2e
def test_five_concurrent_strategies():
    """Test system with 5 concurrent strategies."""
    pass
```

### 5.4 Performance Tests

#### test_strategy_performance.py
```python
"""Performance tests for strategy framework."""


@pytest.mark.performance
def test_throughput_single_strategy():
    """Measure throughput with single strategy."""
    pass


@pytest.mark.performance
def test_throughput_multiple_strategies():
    """Measure throughput with multiple strategies."""
    pass


@pytest.mark.performance
def test_memory_usage():
    """Measure memory usage with strategies."""
    pass


@pytest.mark.performance
def test_latency_distribution():
    """Measure strategy processing latency distribution."""
    pass
```

### 5.5 Test Configurations

#### session_configs/test_single_strategy.json
```json
{
  "mode": "backtest",
  "backtest_config": {
    "start_date": "2024-01-02",
    "end_date": "2024-01-02",
    "speed_multiplier": 0
  },
  "session_data_config": {
    "symbols": ["AAPL"],
    "streams": ["1m", "5m"],
    "strategies": [
      {
        "module": "strategies.examples.simple_ma_cross",
        "enabled": true,
        "config": {
          "symbols": ["AAPL"],
          "interval": "5m",
          "fast_period": 10,
          "slow_period": 20
        }
      }
    ]
  }
}
```

#### session_configs/test_multiple_strategies.json
```json
{
  "mode": "backtest",
  "backtest_config": {
    "start_date": "2024-01-02",
    "end_date": "2024-01-02",
    "speed_multiplier": 0
  },
  "session_data_config": {
    "symbols": ["AAPL", "GOOGL", "TSLA"],
    "streams": ["1m", "5m"],
    "strategies": [
      {
        "module": "strategies.examples.simple_ma_cross",
        "enabled": true,
        "config": {
          "symbols": ["AAPL", "GOOGL"],
          "interval": "5m",
          "fast_period": 10,
          "slow_period": 20
        }
      },
      {
        "module": "strategies.examples.rsi_strategy",
        "enabled": true,
        "config": {
          "symbols": ["TSLA"],
          "interval": "1m",
          "rsi_period": 14
        }
      }
    ]
  }
}
```

---

## Test Coverage Goals

### Unit Tests
- **Target**: 90%+ coverage
- **Focus**: Individual components in isolation
- **Tests**: ~30-40 unit tests

### Integration Tests
- **Target**: 80%+ coverage
- **Focus**: Component interactions
- **Tests**: ~20-30 integration tests

### E2E Tests
- **Target**: Key workflows
- **Focus**: End-to-end scenarios
- **Tests**: ~10-15 E2E tests

### Total
- **~60-85 tests**
- **All modes covered**: data-driven, clock-driven, live
- **All features covered**: lifecycle, subscriptions, notifications, synchronization

---

## Implementation Order

### Week 1 (Days 1-2): Foundation
1. Create directory structure
2. Implement BaseStrategy
3. Implement StrategyConfig
4. Create SimpleMaCrossStrategy example
5. Update SessionDataConfig
6. Write unit tests for base classes

### Week 2 (Days 3-4): Threading
7. Implement StrategyThread
8. Implement notification queue
9. Implement StreamSubscription integration
10. Write unit tests for threading

### Week 3 (Days 5-6): Manager
11. Implement StrategyManager
12. Implement strategy loading
13. Implement subscription routing
14. Write unit tests for manager

### Week 4 (Days 7-8): Integration
15. Wire into SystemManager
16. Wire into DataProcessor
17. Wire into SessionCoordinator
18. Write integration tests

### Week 5 (Days 9-12): Testing
19. E2E tests (data-driven)
20. E2E tests (clock-driven)
21. E2E tests (with scanners)
22. E2E tests (multiple strategies)
23. Performance tests
24. Fix bugs found during testing
25. Documentation review

---

## Success Criteria

### Functionality
- ✅ Strategies load from config
- ✅ Each strategy runs in own thread
- ✅ Selective subscriptions work
- ✅ Zero-copy data access
- ✅ Mode-aware synchronization
- ✅ Performance metrics collected
- ✅ Scanner integration works

### Performance
- ✅ Data-driven: No overhead (blocking OK)
- ✅ Clock-driven: <1ms strategy notification overhead
- ✅ Live: <1ms strategy notification overhead
- ✅ 5 concurrent strategies supported

### Quality
- ✅ 90%+ unit test coverage
- ✅ All E2E tests passing
- ✅ No memory leaks
- ✅ Clean shutdown
- ✅ Comprehensive logging

---

## Risk Mitigation

### Risk: Complex synchronization bugs
**Mitigation**: Use existing StreamSubscription (proven), extensive sync tests

### Risk: Performance degradation
**Mitigation**: Performance tests, profiling, mode-aware execution

### Risk: Strategy errors crash system
**Mitigation**: Try-catch in thread loop, error counting, continue on error

### Risk: Memory leaks from strategies
**Mitigation**: Monitor metrics, cleanup in teardown, test long runs

### Risk: Deadlocks
**Mitigation**: Timeout on all waits, thread debugging, systematic testing

---

## Next Steps

1. **Review this plan** - Get approval
2. **Create Phase 1 files** - Foundation
3. **Write first unit tests** - TDD approach
4. **Implement incrementally** - One phase at a time
5. **Test continuously** - Don't skip testing

**Ready to start Phase 1?**
