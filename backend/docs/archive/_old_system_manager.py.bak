"""System Manager - Central coordinator for all application managers.

This is the top-level singleton that:
1. Creates and manages all other manager singletons (DataManager, ExecutionManager, etc.)
2. Provides references between managers so they can access each other
3. Lives for the entire application lifetime
4. Ensures consistent state across all subsystems
5. Controls application run state (running, paused, stopped)
6. Manages operation mode (live vs backtest)

Architecture:
    SystemManager (singleton)
        ├── DataManager (singleton)
        ├── ExecutionManager (singleton)
        └── AnalysisEngine (singleton)

Each manager receives a reference to SystemManager, allowing them to access
other managers via system_manager.get_xxx_manager().
"""
from typing import Optional, TYPE_CHECKING
from enum import Enum
import json
from pathlib import Path
from datetime import datetime

from app.logger import logger
from app.models.session_config import SessionConfig

# Avoid circular imports
if TYPE_CHECKING:
    from app.managers.data_manager.api import DataManager


class SystemState(Enum):
    """System run states."""
    STOPPED = "stopped"
    RUNNING = "running"
    PAUSED = "paused"


class OperationMode(Enum):
    """System operation modes."""
    LIVE = "live"
    BACKTEST = "backtest"


# Global singleton instance
_system_manager_instance: Optional['SystemManager'] = None


class SystemManager:
    """Central manager that coordinates all application subsystems.
    
    This is a singleton that lives for the entire application lifetime.
    All other managers are created by and registered with the SystemManager.
    
    Benefits:
    - Single source of truth for manager instances
    - Enables inter-manager communication
    - Centralized lifecycle management
    - Consistent state across the application
    
    Usage:
        system_mgr = get_system_manager()
        data_mgr = system_mgr.get_data_manager()
        exec_mgr = system_mgr.get_execution_manager()
    """
    
    def __init__(self):
        """Initialize SystemManager.
        
        WARNING: Do not call directly. Use get_system_manager() instead.
        """
        # Manager instances (lazy-loaded)
        self._time_manager: Optional['TimeManager'] = None
        self._data_manager: Optional['DataManager'] = None
        self._execution_manager: Optional[object] = None  # TODO: Type when implemented
        self._analysis_engine: Optional[object] = None  # TODO: Type when implemented
        
        # Background threads (Phase 3, 4, 5, 7)
        self._coordinator: Optional[object] = None  # SessionCoordinator instance (Phase 3)
        self._data_processor: Optional[object] = None  # DataProcessor instance (Phase 4)
        self._quality_manager: Optional[object] = None  # DataQualityManager instance (Phase 5)
        self._processor_subscription: Optional[object] = None  # StreamSubscription for coordinator-processor sync
        self._analysis_subscription: Optional[object] = None  # StreamSubscription for processor-analysis sync (Phase 7)
        
        # Performance metrics
        from app.monitoring.performance_metrics import PerformanceMetrics
        self._performance_metrics = PerformanceMetrics()
        
        # System-wide state
        self._initialized = False
        self._state = SystemState.STOPPED
        
        # Session configuration (loaded on start)
        self._session_config: Optional[SessionConfig] = None
        
        # Exchange configuration (from session config)
        self.exchange_group: str = "US_EQUITY"  # Default, updated on load_session_config
        self.asset_class: str = "EQUITY"  # Default, updated on load_session_config
        self.timezone: str = None  # Loaded from MarketHours database in _update_exchange_config
        
        # Operation mode (live or backtest)
        from app.config import settings
        mode_str = settings.SYSTEM_OPERATING_MODE.lower()
        self._mode = OperationMode.LIVE if mode_str == "live" else OperationMode.BACKTEST
        
        logger.info(f"SystemManager initialized in {self._mode.value} mode")
    
    def _update_exchange_config(self) -> None:
        """
        Update exchange configuration from session config.
        
        Loads exchange_group, asset_class, and timezone from:
        1. Session config (if available)
        2. MarketHours database (to get timezone)
        3. Falls back to hardcoded defaults
        """
        if self._session_config is None:
            return
        
        # Update from session config
        self.exchange_group = self._session_config.exchange_group
        self.asset_class = self._session_config.asset_class
        
        # Get timezone from database
        from app.models.database import SessionLocal
        from app.models.trading_calendar import MarketHours as MarketHoursDB
        
        try:
            with SessionLocal() as session:
                market_hours = session.query(MarketHoursDB).filter(
                    MarketHoursDB.exchange_group == self.exchange_group,
                    MarketHoursDB.asset_class == self.asset_class,
                    MarketHoursDB.is_active == True
                ).first()
                
                if market_hours:
                    self.timezone = market_hours.timezone
                    logger.info(
                        f"Exchange config: {self.exchange_group}/{self.asset_class} → {self.timezone}"
                    )
                else:
                    # No fallback - timezone MUST come from database
                    raise ValueError(
                        f"No market hours found for {self.exchange_group}/{self.asset_class}. "
                        f"Please run migration to add market hours data to database."
                    )
        except Exception as e:
            logger.error(f"Error loading timezone from database: {e}")
            logger.warning(f"Using default timezone: {self.timezone}")
    
    def get_time_manager(self) -> 'TimeManager':
        """Get or create the TimeManager singleton.
        
        TimeManager is the single source of truth for all date/time and
        market calendar operations.
        
        Returns:
            TimeManager instance with reference to this SystemManager
        """
        if self._time_manager is None:
            from app.managers.time_manager import TimeManager
            self._time_manager = TimeManager(system_manager=self)
            logger.info("TimeManager created by SystemManager")
        return self._time_manager
    
    def get_data_manager(self) -> 'DataManager':
        """Get or create the DataManager singleton.
        
        Returns:
            DataManager instance with reference to this SystemManager
        """
        if self._data_manager is None:
            from app.managers.data_manager.api import DataManager
            self._data_manager = DataManager(system_manager=self)
            logger.info("DataManager created by SystemManager")
        return self._data_manager
    
    def get_execution_manager(self) -> 'ExecutionManager':
        """Get or create the ExecutionManager singleton.
        
        Returns:
            ExecutionManager instance
        """
        if self._execution_manager is None:
            from app.managers.execution_manager import ExecutionManager
            # Initialize with default brokerage from settings
            from app.config import settings
            brokerage = getattr(settings, 'EXECUTION_MANAGER_DEFAULT_BROKERAGE', 'alpaca')
            self._execution_manager = ExecutionManager(mode=self._mode.value, brokerage=brokerage)
            logger.info(f"ExecutionManager created by SystemManager (brokerage: {brokerage})")
        return self._execution_manager
    
    def get_analysis_engine(self) -> object:
        """Get or create the AnalysisEngine singleton.
        
        Returns:
            AnalysisEngine instance (placeholder for now)
        """
        if self._analysis_engine is None:
            # TODO: Implement AnalysisEngine
            logger.warning("AnalysisEngine not yet implemented, returning placeholder")
            self._analysis_engine = object()  # Placeholder
        return self._analysis_engine
    
    def initialize(self):
        """Initialize all managers in correct order.
        
        Call this at application startup to ensure all managers are ready.
        """
        if self._initialized:
            logger.warning("SystemManager already initialized")
            return
        
        logger.info("Initializing SystemManager and all subsystems...")
        
        # Create all managers in dependency order
        # TimeManager first (no dependencies)
        self.get_time_manager()
        self.get_data_manager()
        # self.get_execution_manager()  # TODO: Uncomment when implemented
        # self.get_analysis_engine()     # TODO: Uncomment when implemented
        
        self._initialized = True
        logger.info("SystemManager initialization complete")
    
    def shutdown(self):
        """Shutdown all managers gracefully.
        
        Call this at application shutdown to cleanup resources.
        """
        logger.info("Shutting down SystemManager and all subsystems...")
        
        # Shutdown in reverse dependency order
        # TODO: Add shutdown methods to managers as needed
        
        self._initialized = False
        logger.info("SystemManager shutdown complete")
    
    @property
    def is_initialized(self) -> bool:
        """Check if SystemManager has been initialized."""
        return self._initialized
    
    @property
    def state(self) -> SystemState:
        """Get current system state."""
        return self._state
    
    @property
    def mode(self) -> OperationMode:
        """Get current operation mode."""
        return self._mode
    
    def set_mode(self, mode: str) -> bool:
        """Set operation mode.
        
        Args:
            mode: "live" or "backtest"
            
        Returns:
            True if mode changed successfully, False otherwise
        """
        mode_lower = mode.lower()
        if mode_lower not in ["live", "backtest"]:
            logger.error(f"Invalid mode: {mode}. Must be 'live' or 'backtest'")
            return False
        
        new_mode = OperationMode.LIVE if mode_lower == "live" else OperationMode.BACKTEST
        
        if new_mode == self._mode:
            logger.info(f"Already in {mode_lower} mode")
            return True
        
        # Can only change mode when stopped
        if self._state != SystemState.STOPPED:
            logger.warning(f"Cannot change mode while system is {self._state.value}. Stop the system first.")
            return False
        
        old_mode = self._mode.value
        self._mode = new_mode
        logger.success(f"Operation mode changed: {old_mode} → {new_mode.value}")
        return True
    
    def is_live_mode(self) -> bool:
        """Check if system is in live mode."""
        return self._mode == OperationMode.LIVE
    
    def is_backtest_mode(self) -> bool:
        """Check if system is in backtest mode."""
        return self._mode == OperationMode.BACKTEST
    
    def start(self, config_file_path: str) -> bool:
        """Start the system run with a mandatory configuration file.
        
        STRICT REQUIREMENTS:
        1. config_file_path is mandatory - no defaults or fallbacks
        2. File must exist and be valid JSON
        3. Configuration must pass validation
        4. Data streams are started before transitioning to RUNNING
        5. System state changes only after successful initialization
        
        Args:
            config_file_path: Absolute or relative path to session config JSON file
            
        Returns:
            True if started successfully
            
        Raises:
            ValueError: If config_file_path is None, empty, or invalid
            FileNotFoundError: If config file does not exist
            json.JSONDecodeError: If config file is not valid JSON
            Exception: If configuration validation or stream startup fails
        """
        # STRICT VALIDATION: No null, empty, or missing paths
        if not config_file_path:
            raise ValueError(
                "Configuration file path is mandatory. "
                "You must provide a valid path to a session configuration file."
            )
        
        if not isinstance(config_file_path, str) or not config_file_path.strip():
            raise ValueError(
                f"Invalid configuration file path: {config_file_path}. "
                "Path must be a non-empty string."
            )
        
        # Stop system first to ensure clean state
        # This handles RUNNING, PAUSED, or already STOPPED states
        if self._state != SystemState.STOPPED:
            logger.info(f"System in {self._state.value} state, stopping first...")
            self.stop()
        
        logger.info(f"Starting system with configuration: {config_file_path}")
        
        try:
            # STRICT FILE VALIDATION: File must exist
            config_path = Path(config_file_path)
            if not config_path.exists():
                raise FileNotFoundError(
                    f"Configuration file not found: {config_file_path}\n"
                    f"Absolute path: {config_path.absolute()}\n"
                    "Please provide a valid path to a session configuration file."
                )
            
            if not config_path.is_file():
                raise ValueError(
                    f"Configuration path is not a file: {config_file_path}\n"
                    f"Please provide a path to a JSON configuration file."
                )
            
            # Load and parse JSON configuration
            logger.info(f"Loading configuration from: {config_path.absolute()}")
            with open(config_path, 'r') as f:
                config_data = json.load(f)
            
            # Parse and validate configuration
            logger.info("Parsing and validating session configuration...")
            self._session_config = SessionConfig.from_dict(config_data)
            logger.success(f"Configuration loaded: {self._session_config.session_name}")
            
            # Update exchange configuration from session config
            self._update_exchange_config()
            
            # Apply operation mode from configuration
            if self._session_config.mode != self._mode.value:
                logger.info(f"Setting operation mode to: {self._session_config.mode}")
                if not self.set_mode(self._session_config.mode):
                    raise ValueError(f"Failed to set operation mode to: {self._session_config.mode}")
            
            # Initialize managers if needed
            if not self._initialized:
                self.initialize()
            
            # Apply backtest configuration if in backtest mode
            # TimeManager is responsible for backtest window and time management
            # DataManager is responsible for backtest speed configuration
            time_manager = self.get_time_manager()
            data_manager = self.get_data_manager()
            if self._session_config.mode == "backtest" and self._session_config.backtest_config:
                from app.models.database import SessionLocal
                from datetime import datetime
                
                logger.info(
                    f"Configuring backtest window: {self._session_config.backtest_config.start_date} to "
                    f"{self._session_config.backtest_config.end_date}"
                )
                
                # Parse dates
                start_date = datetime.strptime(self._session_config.backtest_config.start_date, "%Y-%m-%d").date()
                end_date = datetime.strptime(self._session_config.backtest_config.end_date, "%Y-%m-%d").date()
                
                # Set backtest window via TimeManager (this also resets backtest clock)
                with SessionLocal() as db_session:
                    time_manager.set_backtest_window(db_session, start_date, end_date)
                
                # Set backtest speed via DataManager (updates settings as single source of truth)
                data_manager.set_backtest_speed(self._session_config.backtest_config.speed_multiplier)
                logger.info(f"Backtest speed multiplier: {self._session_config.backtest_config.speed_multiplier}")
            
            # Apply API configuration
            logger.info(f"Configuring data API: {self._session_config.api_config.data_api}")
            # TODO: Apply API config to data_manager when API selection is implemented
            
            # =====================================================================
            # NEW ARCHITECTURE: Create and start thread pool
            # =====================================================================
            from app.data.session_data import SessionData
            from app.threads.session_coordinator import SessionCoordinator
            from app.models.database import SessionLocal
            
            # Create SessionData (unified data store)
            logger.info("Creating SessionData...")
            session_data = SessionData()
            
            # Create SessionCoordinator (main orchestrator)
            logger.info("Creating SessionCoordinator...")
            coordinator = SessionCoordinator(
                session_data=session_data,
                system_manager=self,
                session_config=self._session_config,
                metrics=self._performance_metrics,
                data_manager=data_manager
            )
            
            # CRITICAL: Only transition to RUNNING before starting threads
            self._state = SystemState.RUNNING
            
            # Start data processor (Phase 4) and quality manager (Phase 5)
            # Replaces old DataUpkeepThread with focused, event-driven threads
            from app.threads.data_processor import DataProcessor
            from app.threads.data_quality_manager import DataQualityManager
            from app.threads.sync.stream_subscription import StreamSubscription
            from app.config import settings
            
            if settings.DATA_UPKEEP_ENABLED:
                # Create DataProcessor (derived bars + real-time indicators)
                processor = DataProcessor(
                    session_data=session_data,
                    system_manager=self,
                    session_config=self._session_config,
                    metrics=self._performance_metrics
                )
                
                # Create DataQualityManager (quality measurement + gap filling)
                quality_manager = DataQualityManager(
                    session_data=session_data,
                    system_manager=self,
                    session_config=self._session_config,
                    metrics=self._performance_metrics,
                    data_manager=data_manager
                )
                
                # Set up subscription for coordinator-processor synchronization
                processor_subscription = StreamSubscription()
                processor.set_coordinator_subscription(processor_subscription)
                
                # Note: Analysis engine queue will be wired in Phase 7
                # processor.set_analysis_engine_queue(analysis_queue)
                
                # Wire threads into coordinator
                coordinator.set_data_processor(processor, processor_subscription)
                coordinator.set_quality_manager(quality_manager)
                
                # Start threads
                processor.start()
                quality_manager.start()
                
                logger.info("✓ Data processor started (derived bars, indicators)")
                logger.info("✓ Quality manager started (quality measurement, gap filling)")
                
                # Store references for cleanup
                self._data_processor = processor
                self._quality_manager = quality_manager
                self._processor_subscription = processor_subscription
                
                # Start analysis engine (Phase 7)
                from app.threads.analysis_engine import AnalysisEngine
                from app.strategies import SMAcrossoverStrategy, RSIStrategy
                import queue as queue_module
                
                # Create AnalysisEngine
                analysis_engine = AnalysisEngine(
                    session_data=session_data,
                    system_manager=self,
                    session_config=self._session_config,
                    metrics=self._performance_metrics
                )
                
                # Create notification queue and subscription for processor-analysis sync
                analysis_queue = queue_module.Queue()
                analysis_subscription = StreamSubscription()
                
                # Wire notification queue to processor
                processor.set_analysis_engine_queue(analysis_queue)
                processor.set_analysis_subscription(analysis_subscription)
                
                # Wire to analysis engine
                analysis_engine.set_notification_queue(analysis_queue)
                analysis_engine.set_processor_subscription(analysis_subscription)
                
                # Register example strategies
                # TODO: Load from configuration
                sma_strategy = SMAcrossoverStrategy(
                    name="SMA_Crossover",
                    session_data=session_data,
                    config={'fast_period': 5, 'slow_period': 20, 'quantity': 10, 'intervals': ['5m']}
                )
                analysis_engine.register_strategy(sma_strategy)
                
                rsi_strategy = RSIStrategy(
                    name="RSI_MeanReversion",
                    session_data=session_data,
                    config={'period': 14, 'oversold_threshold': 30, 'overbought_threshold': 70, 'quantity': 10, 'intervals': ['5m']}
                )
                analysis_engine.register_strategy(rsi_strategy)
                
                # Start analysis engine
                analysis_engine.start()
                logger.info("✓ Analysis engine started (strategy execution, signal generation)")
                
                # Store references
                self._analysis_engine = analysis_engine
                self._analysis_subscription = analysis_subscription
            else:
                self._data_processor = None
                self._quality_manager = None
                self._processor_subscription = None
                self._analysis_engine = None
                self._analysis_subscription = None
                logger.warning("Data processor, quality manager, and analysis engine disabled in settings")
            
            # Store coordinator reference
            self._coordinator = coordinator
            
            # Start SessionCoordinator thread (orchestrates everything)
            logger.info("Starting SessionCoordinator...")
            coordinator.start()
            logger.success("✓ SessionCoordinator started")
            
            # Build success message
            symbols = self._session_config.session_data_config.symbols
            streams = self._session_config.session_data_config.streams
            
            success_msg = (
                f"System started successfully!\n"
                f"  Session: {self._session_config.session_name}\n"
                f"  Mode: {self._session_config.mode.upper()}\n"
            )
            
            if self._session_config.mode == "backtest" and self._session_config.backtest_config:
                success_msg += (
                    f"  Backtest Window: {self._session_config.backtest_config.start_date} to "
                    f"{self._session_config.backtest_config.end_date}\n"
                    f"  Speed: {self._session_config.backtest_config.speed_multiplier}x (0=max)\n"
                )
            
            success_msg += (
                f"  Symbols: {len(symbols)} ({', '.join(symbols)})\n"
                f"  Streams: {len(streams)} ({', '.join(streams)})\n"
                f"  Max Buying Power: ${self._session_config.trading_config.max_buying_power:,.2f}\n"
                f"  Max Per Trade: ${self._session_config.trading_config.max_per_trade:,.2f}\n"
                f"  Paper Trading: {self._session_config.trading_config.paper_trading}\n"
            )
            
            success_msg += "\nSessionCoordinator is now managing the session lifecycle."
            
            logger.success(success_msg)
            return True
            
        except FileNotFoundError:
            # Re-raise file not found errors as-is
            raise
        except json.JSONDecodeError as e:
            # Invalid JSON format
            raise json.JSONDecodeError(
                f"Configuration file contains invalid JSON: {config_file_path}\n"
                f"Error: {e.msg}",
                e.doc,
                e.pos
            )
        except ValueError as e:
            # Configuration validation failed
            raise ValueError(
                f"Configuration validation failed: {config_file_path}\n"
                f"Error: {str(e)}"
            )
        except Exception as e:
            # Any other error during startup
            logger.error(f"System startup failed: {e}", exc_info=True)
            # Ensure system remains in STOPPED state on failure
            self._state = SystemState.STOPPED
            raise Exception(f"System startup failed: {str(e)}") from e
    
    def pause(self) -> bool:
        """Pause the system run.
        
        Transitions from RUNNING to PAUSED.
        Managers should suspend operations but maintain state.
        
        Returns:
            True if paused successfully, False if not running
        """
        if self._state != SystemState.RUNNING:
            logger.warning(f"Cannot pause system in state: {self._state.value}")
            return False
        
        logger.info("Pausing system...")
        
        # Pause all managers
        # TODO: Add manager-specific pause logic as needed
        
        self._state = SystemState.PAUSED
        logger.success("System paused")
        return True
    
    def resume(self) -> bool:
        """Resume the system from paused state.
        
        Transitions from PAUSED to RUNNING.
        
        Returns:
            True if resumed successfully, False if not paused
        """
        if self._state != SystemState.PAUSED:
            logger.warning(f"Cannot resume system in state: {self._state.value}")
            return False
        
        logger.info("Resuming system...")
        
        # Resume all managers
        # TODO: Add manager-specific resume logic as needed
        
        self._state = SystemState.RUNNING
        logger.success("System resumed")
        return True
    
    def stop(self) -> bool:
        """Stop the system run.
        
        Transitions from any state to STOPPED.
        Stops all active data streams and cleans up resources.
        
        Returns:
            True if stopped successfully, False if already stopped
        """
        if self._state == SystemState.STOPPED:
            logger.debug("System already stopped")
            return True  # Already in desired state, not an error
        
        logger.info(f"Stopping system from state: {self._state.value}...")
        
        # Stop threads in reverse order: analysis → processor → quality → coordinator
        if hasattr(self, '_analysis_engine') and self._analysis_engine is not None:
            logger.info("Stopping analysis engine...")
            self._analysis_engine.stop()
            self._analysis_engine.join(timeout=5.0)
            self._analysis_engine = None
            logger.success("Analysis engine stopped")
        
        if hasattr(self, '_data_processor') and self._data_processor is not None:
            logger.info("Stopping data processor...")
            self._data_processor.stop()
            self._data_processor.join(timeout=5.0)
            self._data_processor = None
            logger.success("Data processor stopped")
        
        if hasattr(self, '_quality_manager') and self._quality_manager is not None:
            logger.info("Stopping quality manager...")
            self._quality_manager.stop()
            self._quality_manager.join(timeout=5.0)
            self._quality_manager = None
            logger.success("Quality manager stopped")
        
        # Stop coordinator (main orchestrator)
        if hasattr(self, '_coordinator') and self._coordinator is not None:
            logger.info("Stopping session coordinator...")
            self._coordinator.stop()
            self._coordinator.join(timeout=5.0)
            self._coordinator = None
            logger.success("Session coordinator stopped")
        
        # Clear session configuration
        self._session_config = None
        
        # Transition to STOPPED state
        self._state = SystemState.STOPPED
        logger.success("System stopped")
        return True
    
    def is_running(self) -> bool:
        """Check if system is in RUNNING state."""
        return self._state == SystemState.RUNNING
    
    def is_paused(self) -> bool:
        """Check if system is in PAUSED state."""
        return self._state == SystemState.PAUSED
    
    def is_stopped(self) -> bool:
        """Check if system is in STOPPED state."""
        return self._state == SystemState.STOPPED
    
    @property
    def session_data(self):
        """Get the global session_data singleton.
        
        Returns:
            SessionData instance
        """
        from app.managers.data_manager.session_data import get_session_data
        return get_session_data()
    
    @property
    def session_config(self) -> Optional[SessionConfig]:
        """Get the current session configuration.
        
        Returns:
            SessionConfig if a session is active, None otherwise
        """
        return self._session_config


def get_system_manager() -> SystemManager:
    """Get or create the global SystemManager singleton instance.
    
    This is the main entry point for accessing the SystemManager.
    
    Returns:
        The singleton SystemManager instance
    """
    global _system_manager_instance
    if _system_manager_instance is None:
        _system_manager_instance = SystemManager()
        logger.info("SystemManager singleton instance created")
    return _system_manager_instance


def reset_system_manager() -> None:
    """Reset the global SystemManager singleton (useful for testing).
    
    WARNING: This will destroy all manager instances. Use with caution.
    """
    global _system_manager_instance
    if _system_manager_instance is not None:
        _system_manager_instance.shutdown()
    _system_manager_instance = None
    logger.info("SystemManager singleton instance reset")
